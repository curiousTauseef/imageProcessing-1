// Name: Maroof Mohammed Farooq// HW P2// Image Processing#include <stdio.h>#include <iostream>#include <stdlib.h>#include <vector>#include <fstream>#include <iterator>#include <math.h>#include <map>#include <unordered_map>#include "opencv2/imgproc/imgproc.hpp"#include "opencv2/highgui/highgui.hpp"#include "imageData.h"#include "imageAlgorithms.h"#include "matrix.h"using namespace std;using namespace cv;Mat src, src_gray;Mat dst;int main(int argc, char *argv[]) {	// Define file pointer and variables	int BytesPerPixel;	int imageWidth;	int imageHeight;	int problemNumber;//----------------------------------------------------------------------------------------------------------------//	// Check for proper syntax	if (argc < 3) {		cout << "Syntax Error - Incorrect Parameter Usage:" << endl;		cout <<		"program_name input_image.raw output_image.raw [BytesPerPixel = 1] [imageWidth = 256] [imageHeight = 256]" <<		endl;		return 0;	}	// Check if image is grayscale or color	if (argc < 4) {		BytesPerPixel = 1;// default is grey image		imageHeight = 256;		imageWidth = 256;	}	else {		BytesPerPixel = atoi(argv[3]);		// Check if size is specified		if (argc >= 5) {			imageWidth = atoi(argv[4]);			imageHeight = atoi(argv[5]);		}		else {			imageHeight = 256;			imageWidth = 256;		}	}	problemNumber = atoi(argv[6]);//----------------------------------------------------------------------------------------------------------------//// input and output file names	string inputFileName = argv[1];	string outputFileName = argv[2];//----------------------------------------------------------------------------------------------------------------//// 1(a) Texture Classification	if(problemNumber ==1){		matrix<int,int> test(3,3,1);		test.setMatrixByValues(9,1,2,3,4,5,6,7,8,9);		matrix<int,int> testout = test.extendMatrix(2);		testout.printMatrix();	}	if (problemNumber == 2) {		// Reading additional arguments:		if(argc!=8){			cout<< "Incorrect number of arguments for problem 1!" <<endl;			exit(0);		}		int trainingSize = atoi(argv[7]);		// Read 12 training images		vector<imageData*> trainingImages;		vector<Mat> matFiles;		for(int i = 1; i<=trainingSize; i++){			imageData* trainImage = new imageData(BytesPerPixel,imageWidth,imageHeight);			trainImage->imageRead(("HW3 Images/P1/Texture"+to_string(i)+".raw").c_str());			Mat tempImage = trainImage->convertToMat();			trainingImages.push_back(trainImage);			matFiles.push_back((tempImage));		}		// Create object for image algorithms		imageAlgorithms lawsAlgorithm(trainingImages[0]);		// Step 1: Remove DC Component from filter		vector<matrix<int,double> > subtractedDCImages;		for_each(trainingImages.begin(),trainingImages.end(),[&](imageData* image){			subtractedDCImages.push_back(lawsAlgorithm.subtractDC(*image));		});		// Step 2: Create Law's filter		map<int,matrix<int,double> > filterBank = lawsAlgorithm.getLawsFilter();		// Step 3: Convolve laws filter with input image		// Step 4: Calculate energy of filter response//		// Create Law's filter//		map<int,matrix<int,double> > filterBank = lawsAlgorithm.getLawsFilter();////		// Print Filters////		for(int i = 0; i< 25;i++){////			filterBank[i].printMatrix();////		}////		// Apply Filters and reduce it to 25D Energy vector//		map<int, matrix<int,double> > outputImages;//		unordered_map<int, vector<double> > energyValues;//		energyValues.reserve(trainingSize);//		double DC_Component;////		for(int imageNumber = 0; imageNumber<trainingSize; imageNumber++){////			DC_Component = lawsAlgorithm.calculateDC(*trainingImages[imageNumber]);//			for(int filterNumber = 0; filterNumber < 25; filterNumber++){////				outputImages[filterNumber] = lawsAlgorithm.filterApply(*trainingImages[imageNumber],filterBank[filterNumber],"convolutionWithoutAbsolute");//				energyValues[imageNumber].push_back(lawsAlgorithm.imageEnergy(outputImages[filterNumber],DC_Component));//			}//		}//		for_each(energyValues[0].begin(),energyValues[0].end(),[=](int x){cout<< x <<endl;});//		cout<< energyValues[0][0] <<endl;//		namedWindow( "Display window", WINDOW_AUTOSIZE );// Create a window for display.//		imshow( "Display window", (matFiles[1]));                   // Show our image inside it.//		waitKey(0);                                          // Wait for a keystroke in the	}	return 0;}